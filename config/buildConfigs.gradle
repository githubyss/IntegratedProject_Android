apply from: "${rootDir}/config/featureConfigs.gradle"
apply from: "${rootDir}/config/signingConfigs.gradle"
apply from: "${rootDir}/config/versionConfigs.gradle"

android {
    /**
     * 构建工具的版本。
     * 其中包括了打包工具 aapt、dx 等等。这个工具的目录位于..sdk_path/build-tools/XX.XX.XX。
     */
    buildToolsVersion androidVersion.build_tools_version

    /**
     * SDK 编译版本。
     * 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。
     * 修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。
     * 强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API，并且为使用新的 API 做好准备。
     *
     * 就是运行我们这个项目的需要的 SDK。比如如果我们需要在 Android 10.0 Q (API 29) 的版本运行，只要改为 29 就好了。
     */
    compileSdkVersion androidVersion.compile_sdk_version

    /**
     * defaultConfig：默认构建类型，主要针对开发生命周期的不同阶段进行配置。
     * defaultConfig 是 Android 中的一个默认的配置块，用来定义一些默认配置。它是一个 ProductFlavor，如果一个 productFlavors 没有为某些属性指定特定的配置的话，就会采用默认配置块中的默认配置。比如包名、版本号、版本名等。
     */
    defaultConfig {
        /**
         * 理想上，在稳定状态下三者的关系应该更像这样：
         * minSdkVersion (lowest possible) <= targetSdkVersion == compileSdkVersion (latest SDK)
         * 用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 targetSdkVersion 和 compileVersion 来获得最好的外观和行为。
         */

        /**
         * 最小支持的 SDK 版本（手机的 Android 系统版本）。
         * 如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。
         * minSdkVersion 是各大 Android 应用商店用来判断用户设备是否可以安装某个应用的标志之一。
         * 在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，它在你使用了低于 minSdkVersion 的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。
         */
        minSdkVersion androidVersion.min_sdk_version

        /**
         * 新特性支持的 SDK 版本。
         * targetSdkVersion 是 Android 提供向前兼容的主要依据。
         * 随着 Android 系统的升级，某个系统的 API 或者模块的行为会发生改变，但是为了保证老APK的行为与之前一致兼容，只要 apk 中的 targetSdkVersion 不变，即使这个 APK 安装到新的系统上，其行为还是保持老的系统上的。
         * 在应用的 targetSdkVersion 没有更新之前，系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API（因为你已经更新了 compileSdkVersion 不是吗？）
         * targetSdkVersion 指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特征。比如，Android 6.0 (API 23) 系统引用了运行时权限这个功能，如果你将 targetSdkVersion 指定为 23 或者更高，那么系统就会为你的程序启动运行时权限。如果你将 targetSdkVersion 指定为 22，那么就说明你的程序最高只在 Android 5.1 (API 22) 系统上做过充分的测试，Android 6.0 系统中引入的新功能就不会启动了。
         * 说通俗一点：
         * 比如你将 targetSdkVersion 设置为 22，涉及某个（或某几个）权限，你直接在 mainfest 中配置权限即可，然后在 java 代码中进行获取权限后的逻辑处理即可。
         * 但如果你将 targetSdkVersion 设置为 23 或更高，你除了在 mainfest 中配置权限外，还需要在 java 代码中判断用户是否同意权限，如果同意，执行什么业务操作；如果不同意，执行什么业务操作（一般是提示某某权限被拒后，某某功能无法正常使用）。如果你只在 mainfest 中配置了权限，targetSdkVersion 又大于等于 23，Java 代码中不进行运行时权限的代码，你的应用程序就直接报错了。
         */
        targetSdkVersion androidVersion.target_sdk_version

        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'

        // 混淆文件配置
        // Android 本身已经提供了两份关于 proguard 的配置文件，放在 sdk/tools/proguard 目录下面。
        // 一个是 proguard-android-optimize.txt，另一个是 proguard-android.txt。两者最主要的区别是前者加入了一些优化命令。
        // proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), "${rootDir.getAbsolutePath()}/proguard/proguard-rules.pro"
        consumerProguardFiles 'consumer-rules.pro'
    }

    /** buildTypes：构建类型，主要针对开发生命周期的不同阶段进行配置。 */
    buildTypes {
        // 调试版本
        debug {
            // 是否可以调试
            // Java 和 Kotlin 中，可以通过 BuildConfig.DEBUG 获取
            debuggable feature.isDebuggable
            // 是否开启混淆
            minifyEnabled feature.isMinifyEnabled
            // 是否启用 zipAlign 压缩
            zipAlignEnabled feature.isZipAlignEnabled

            signingConfig signingConfigs.debug
        }

        // 发布版本
        release {
            debuggable false
            minifyEnabled true
            zipAlignEnabled true

            if (signingProperties.RELEASE_STORE_FILE.exists()) {
                signingConfig signingConfigs.release
            }
        }
    }
}

kapt {
    arguments {
        arg('moduleName', project.getName())
    }
}
